#!/usr/bin/env python
# coding: utf-8

# In[ ]:


"C:/Users/DELL/Downloads/t2dah_e/t2dah_e/t2dah_e.mtx",
"C:/Users/DELL/Downloads/Pres_Poisson/Pres_Poisson/Pres_Poisson.mtx",
"C:/Users/DELL/Downloads/nd6k/nd6k/nd6k.mtx",
"C:/Users/DELL/Downloads/bodyy4/bodyy4/bodyy4.mtx",
"C:/Users/DELL/Downloads/Trefethen_20000b/Trefethen_20000b/Trefethen_20000b.mtx",
"C:/Users/DELL/Downloads/bcsstk36/bcsstk36/bcsstk36.mtx",
"C:/Users/DELL/Downloads/msc23052/msc23052/msc23052.mtx",
"C:/Users/DELL/Downloads/thread/thread/thread.mtx",
"C:/Users/DELL/Downloads/ship_001/ship_001/ship_001.mtx",
"C:/Users/DELL/Downloads/nd12k/nd12k/nd12k.mtx",
"C:/Users/DELL/Downloads/cvxbqp1/cvxbqp1/cvxbqp1.mtx",
"C:/Users/DELL/Downloads/cant/cant/cant.mtx",
"C:/Users/DELL/Downloads/G3_circuit/G3_circuit/G3_circuit.mtx",
"C:/Users/DELL/Downloads/hood/hood/hood.mtx",
"C:/Users/DELL/Downloads/Flan_1565/Flan_1565/Flan_1565.mtx",
"C:/Users/DELL/Downloads/1138_bus/1138_bus/1138_bus.mtx",
"C:/Users/DELL/Downloads/bcsstk01/bcsstk01/bcsstk01.mtx",
"C:/Users/DELL/Downloads/bcspwr10/bcspwr10/bcspwr10.mtx",
"C:/Users/DELL/Downloads/case39/case39/case39.mtx",
"C:/Users/DELL/Downloads/Kuu/Kuu/Kuu.mtx",
"C:/Users/DELL/Downloads/bcsstk38/bcsstk38/bcsstk38.mtx",
"C:/Users/DELL/Downloads/nd3k/nd3k/nd3k.mtx",
"C:/Users/DELL/Downloads/bundle1/bundle1/bundle1.mtx",
"C:/Users/DELL/Downloads/ted_B/ted_B/ted_B.mtx",
"C:/Users/DELL/Downloads/msc10848/msc10848/msc10848.mtx"


# In[ ]:


"C:/Users/DELL/Downloads/nos5.mtx/nos5.mtx",
    "C:/Users/DELL/Downloads/s3rmt3m3.mtx/s3rmt3m3.mtx",
    #"C:/Users/DELL/Downloads/bcsstk01.mtx/BCS Structural Engineering Matrices (eigenvalue matrices).mtx",
    "C:/Users/DELL/Downloads/bcsstk05.mtx/BCS Structural Engineering Matrices (eigenvalue matrices) Transmission Towers.mtx",
    "C:/Users/DELL/Downloads/bcsstk11.mtx/BCS Structural Engineering Matrices (eigenvalue matrices) Ore car -- lumped mass.mtx",
    "C:/Users/DELL/Downloads/bcsstk08.mtx/BCS Structural Engineering Matrices (eigenvalue matrices) TV STUDIO.mtx",
    "C:/Users/DELL/Downloads/bcsstm09.mtx/BCS Structural Engineering Matrices (eigenvalue matrices) SQUARE PLATE CLAMPED.mtx",
    "C:/Users/DELL/Downloads/e30r5000.mtx/Driven cavity.mtx",
    "C:/Users/DELL/Downloads/fs_680_2.mtx/Chemical kinetics problems.mtx",
    "C:/Users/DELL/Downloads/e40r3000.mtx/driven cavity.mtx",
    "C:/Users/DELL/Downloads/fidap013.mtx/fidap013.mtx",
    "C:/Users/DELL/Downloads/fidapm15.mtx/fidapm15.mtx",
    "C:/Users/DELL/Downloads/gemat11.mtx/gemat11.mtx",
    "C:/Users/DELL/Downloads/fidapm29.mtx/fidapm29.mtx",
    "C:/Users/DELL/Downloads/fidapm37.mtx/fidapm37.mtx"


# In[ ]:


"C:/Users/DELL/OneDrive/Documents/samplesss./SPMV-DOUBLE.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./SPMV-FLOAT.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./SPMV10X-FLOAT.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./SPMV10X-DOUBLE.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./SPMV-DOUBLE-DIAGONAL.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./SPMV-DOUBLE-AVX.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./SPMV-FLOAT-SSE.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./SPMV-FLOAT-AVX.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./SPMV-DOUBLE-SSE.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./SPMV-FLOAT-AVX-ALIGNMENT4.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./SPMV-DOUBLE-AVX-ALIGNMENT4",
"C:/Users/DELL/OneDrive/Documents/samplesss./SPMV-FLOAT-AVX-ALIGNMENT8",
"C:/Users/DELL/OneDrive/Documents/samplesss./SPMV10X-DOUBLE-AVX.exe"
"C:/Users/DELL/OneDrive/Documents/samplesss./SPMV10X-DOUBLE-SSE.exe"
"C:/Users/DELL/OneDrive/Documents/samplesss./SPMV10X-DOUBLE-AVX-ALIGNMENT4.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./SPMV10X-FLOAT-AVX.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./SPMV10X-FLOAT-AVX-ALIGNMENT8.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./SPMV10X-FLOAT-SSE.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV-DOUBLE.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV-FLOAT.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV10X-DOUBLE.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV10X-FLOAT.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV-FLOAT-SSE.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV-DOUBLE-SSE.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV10X-DOUBLE-SSE.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV10X-FLOAT-SSE.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV-DOUBLE-AVX.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV-DOUBLE-DIAGONAL.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV-FLOAT-AVX.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV10X-DOUBLE-AVX.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV10X-FLOAT-AVX.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV10X-DOUBLE-AVX-ALIGNMENT4.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV-DOUBLE-AVX-ALIGNMENT4.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV10X-FLOAT-AVX-ALIGNMENT8.exe",
"C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV-FLOAT-AVX-ALIGNMENT4.exe"


# In[ ]:





# In[ ]:





# In[ ]:





# In[ ]:





# In[1]:


import re
import os
import statistics
import json
import subprocess
from collections import defaultdict

def parse_output(output, exec_name):
    times = {
        'convert': None,
        'multiply_add': None,
        'total': None,
        'form_vector': None
    }
    matrix_info = None
    
    patterns = {
        'convert': r'Time elapsed to convert double to float: (\d+\.\d+) seconds',
        'multiply_add': r'Time elapsed for multiplying and adding both: (\d+\.\d+) seconds',
        'total': r'Total time elapsed: (\d+\.\d+) seconds',
        'form_vector': r'Time elapsed to form the new vector is : (\d+\.\d+) seconds'
    }
    
    matrix_pattern = r'Rows: (\d+), Columns: (\d+), Non-zero elements: (\d+)'
    
    for line in output.split('\n'):
        for key, pattern in patterns.items():
            match = re.search(pattern, line)
            if match:
                times[key] = float(match.group(1))
        
        matrix_match = re.search(matrix_pattern, line)
        if matrix_match:
            matrix_info = {
                'rows': int(matrix_match.group(1)),
                'columns': int(matrix_match.group(2)),
                'non_zero': int(matrix_match.group(3))
            }
    
    return times, matrix_info

def run_spmv(exec_name, matrix_file):
    times = {
        'convert': [],
        'multiply_add': [],
        'total': [],
        'form_vector': []
    }
    matrix_info = None

    for run in range(3):
        try:
            result = subprocess.run([exec_name, matrix_file], capture_output=True, text=True, timeout=300)
            
            if result.returncode != 0:
                print(f"Error running {exec_name} for {matrix_file} (Run {run + 1}):")
                print(result.stderr)
                continue
            
            run_times, run_matrix_info = parse_output(result.stdout, exec_name)
            
            for key in times:
                if run_times[key] is not None:
                    times[key].append(run_times[key])
            
            if not matrix_info and run_matrix_info:
                matrix_info = run_matrix_info
            
        except subprocess.TimeoutExpired:
            print(f"Timeout occurred for {exec_name} with {matrix_file} (Run {run + 1})")
        except Exception as e:
            print(f"Exception occurred for {exec_name} with {matrix_file} (Run {run + 1}): {e}")
    
    if any(times.values()) and matrix_info:
        return {
            'file': os.path.basename(matrix_file),
            'times': {k: statistics.median(v) if v else None for k, v in times.items()},
            'rows': matrix_info['rows'],
            'columns': matrix_info['columns'],
            'non_zero': matrix_info['non_zero']
        }
    else:
        print(f"No valid runs for {exec_name} with {matrix_file}")
        return None

def classify_executable(exec_name):
    name = os.path.basename(exec_name).lower()
    variant = '10x' if '10x' in name else 'normal'
    precision = 'double' if 'double' in name else 'float'
    instruction_set = 'sse' if 'sse' in name else 'avx' if 'avx' in name else 'scalar'
    compiler = 'icc' if 'icc' in name else 'gcc'
    return f"{variant}_{precision}_{instruction_set}_{compiler}"

# Your matrix_files and exec_files lists here
matrix_files = [
    "C:/Users/DELL/Downloads/t2dah_e/t2dah_e/t2dah_e.mtx",
    "C:/Users/DELL/Downloads/Pres_Poisson/Pres_Poisson/Pres_Poisson.mtx",
    "C:/Users/DELL/Downloads/nd6k/nd6k/nd6k.mtx",
    "C:/Users/DELL/Downloads/bodyy4/bodyy4/bodyy4.mtx",
    "C:/Users/DELL/Downloads/Trefethen_20000b/Trefethen_20000b/Trefethen_20000b.mtx",
    "C:/Users/DELL/Downloads/bcsstk36/bcsstk36/bcsstk36.mtx",
    "C:/Users/DELL/Downloads/msc23052/msc23052/msc23052.mtx",
    "C:/Users/DELL/Downloads/thread/thread/thread.mtx",
    "C:/Users/DELL/Downloads/ship_001/ship_001/ship_001.mtx",
    "C:/Users/DELL/Downloads/nd12k/nd12k/nd12k.mtx",
    "C:/Users/DELL/Downloads/cvxbqp1/cvxbqp1/cvxbqp1.mtx",
    "C:/Users/DELL/Downloads/cant/cant/cant.mtx",
    "C:/Users/DELL/Downloads/G3_circuit/G3_circuit/G3_circuit.mtx",
    "C:/Users/DELL/Downloads/hood/hood/hood.mtx",
    "C:/Users/DELL/Downloads/Flan_1565/Flan_1565/Flan_1565.mtx",
    "C:/Users/DELL/Downloads/1138_bus/1138_bus/1138_bus.mtx",
    "C:/Users/DELL/Downloads/bcsstk01/bcsstk01/bcsstk01.mtx",
    "C:/Users/DELL/Downloads/bcspwr10/bcspwr10.mtx",
    "C:/Users/DELL/Downloads/case39/case39/case39.mtx",
    "C:/Users/DELL/Downloads/Kuu/Kuu/Kuu.mtx",
    "C:/Users/DELL/Downloads/bcsstk38/bcsstk38/bcsstk38.mtx",
    "C:/Users/DELL/Downloads/nd3k/nd3k/nd3k.mtx",
    "C:/Users/DELL/Downloads/bundle1/bundle1/bundle1.mtx",
    "C:/Users/DELL/Downloads/ted_B/ted_B/ted_B.mtx",
    "C:/Users/DELL/Downloads/msc10848/msc10848/msc10848.mtx"
]

exec_files = [
    "C:/Users/DELL/OneDrive/Documents/samplesss./SPMV-DOUBLE.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./SPMV-FLOAT.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./SPMV10X-FLOAT.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./SPMV10X-DOUBLE.exe",
    #"C:/Users/DELL/OneDrive/Documents/samplesss./SPMV-DOUBLE-DIAGONAL.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./SPMV-DOUBLE-AVX.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./SPMV-FLOAT-SSE.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./SPMV-FLOAT-AVX.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./SPMV-DOUBLE-SSE.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./SPMV-FLOAT-AVX-ALIGNMENT4.exe",
    #"C:/Users/DELL/OneDrive/Documents/samplesss./SPMV-DOUBLE-AVX-ALIGNMENT4.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./SPMV-FLOAT-AVX-ALIGNMENT8.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./SPMV10X-DOUBLE-AVX.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./SPMV10X-DOUBLE-SSE.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./SPMV10X-DOUBLE-AVX-ALIGNMENT4.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./SPMV10X-FLOAT-AVX.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./SPMV10X-FLOAT-AVX-ALIGNMENT8.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./SPMV10X-FLOAT-SSE.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV-DOUBLE.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV-FLOAT.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV10X-DOUBLE.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV10X-FLOAT.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV-FLOAT-SSE.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV-DOUBLE-SSE.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV10X-DOUBLE-SSE.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV10X-FLOAT-SSE.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV-DOUBLE-AVX.exe",
    #"C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV-DOUBLE-DIAGONAL.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV-FLOAT-AVX.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV10X-DOUBLE-AVX.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV10X-FLOAT-AVX.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV10X-DOUBLE-AVX-ALIGNMENT4.exe",
    #"C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV-DOUBLE-AVX-ALIGNMENT4.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV10X-FLOAT-AVX-ALIGNMENT8.exe",
    "C:/Users/DELL/OneDrive/Documents/samplesss./ICC-SPMV-FLOAT-AVX-ALIGNMENT4.exe"
]

results = defaultdict(lambda: defaultdict(list))

for exec_file in exec_files:
    variant = classify_executable(exec_file)
    for matrix_file in matrix_files:
        result = run_spmv(exec_file, matrix_file)
        if result:
            results[variant][os.path.basename(matrix_file)] = result
        else:
            # Add a placeholder result with None values
            results[variant][os.path.basename(matrix_file)] = {
                'file': os.path.basename(matrix_file),
                'times': {k: None for k in ['convert', 'multiply_add', 'total', 'form_vector']},
                'rows': None,
                'columns': None,
                'non_zero': None
            }

# Save results to a JSON file
with open('spmv_results.json', 'w') as f:
    json.dump(results, f, indent=2)

print("Results saved to spmv_results.json")


# In[ ]:





# In[ ]:





# In[2]:


import json
import matplotlib.pyplot as plt
import numpy as np
from collections import defaultdict
import os

def load_results(filename):
    with open(filename, 'r') as f:
        return json.load(f)

def plot_results(results, selected_executables):
    variants = [variant for variant in results.keys() if variant in selected_executables]
    n_variants = len(variants)
    n_matrices = max(len(results[variant]) for variant in variants)
    
    fig, axs = plt.subplots(2, 2, figsize=(20, 20))
    width = 0.8 / n_variants
    x = np.arange(n_matrices)
    
    time_types = ['convert', 'multiply_add', 'form_vector', 'total']
    
    for i, (ax, time_type) in enumerate(zip(axs.flat, time_types)):
        for j, variant in enumerate(variants):
            if time_type == 'total':
                # Stacked bar for total time
                bottom = np.zeros(len(results[variant]))
                for sub_time in ['form_vector', 'convert', 'multiply_add']:
                    times = [result['times'][sub_time] or 0 for result in results[variant].values()]
                    x_pos = x[:len(times)] + j*width - (n_variants-1)*width/2
                    bars = ax.bar(x_pos, times, width, bottom=bottom, label=f"{variant}_{sub_time}", alpha=0.8)
                    bottom += times
                    
                    # Annotate each segment
                    for k, bar in enumerate(bars):
                        height = bar.get_height()
                        if height > 0:
                            ax.annotate(f'{height:.2e}',
                                        xy=(bar.get_x() + bar.get_width() / 2, bottom[k]),
                                        xytext=(0, -3),
                                        textcoords="offset points",
                                        ha='center', va='top', rotation=90, fontsize=6)
            else:
                # Regular bar for other time types
                exec_times = [result['times'][time_type] for result in results[variant].values() if result['times'][time_type] is not None]
                if exec_times:
                    x_pos = x[:len(exec_times)] + j*width - (n_variants-1)*width/2
                    bars = ax.bar(x_pos, exec_times, width, label=variant, alpha=0.8)
                    
                    for bar in bars:
                        height = bar.get_height()
                        ax.annotate(f'{height:.2e}',
                                    xy=(bar.get_x() + bar.get_width() / 2, height),
                                    xytext=(0, 3),
                                    textcoords="offset points",
                                    ha='center', va='bottom', rotation=90, fontsize=6)
        
        # Use the variant with the most results for x-axis labels
        max_variant = max(results, key=lambda k: len(results[k]))
        matrix_info = [f"{result['file']}\nM={result['rows']}, N={result['columns']}\nNZ={result['non_zero']}" 
                       for result in results[max_variant].values()]
        
        ax.set_title(f'{time_type.replace("_", " ").capitalize()} Time', fontsize=14)
        ax.set_xlabel('Matrices', fontsize=12)
        ax.set_ylabel('Time (seconds)', fontsize=12)
        ax.set_xticks(x)
        ax.set_xticklabels(matrix_info, rotation=45, ha='right', fontsize=6)
        ax.legend(fontsize=8, loc='upper left', bbox_to_anchor=(1, 1))
        ax.set_yscale('log')
        ax.grid(axis='y', linestyle='--', alpha=0.7)
    
    plt.tight_layout()
    plt.show()

def calculate_improvements(results, time_type, selected_executables):
    improvements = defaultdict(list)
    baseline = 'normal_double_scalar_gcc'  # Assuming this is our baseline for comparison
    
    if baseline not in results or baseline not in selected_executables:
        print(f"Baseline '{baseline}' not found in results or not selected.")
        return improvements

    for variant in results:
        if variant != baseline and variant in selected_executables:
            for matrix, variant_result in results[variant].items():
                baseline_result = results[baseline].get(matrix)
                if baseline_result:
                    variant_time = variant_result['times'][time_type]
                    baseline_time = baseline_result['times'][time_type]
                    
                    if variant_time is not None and baseline_time is not None and baseline_time != 0:
                        improvement = (baseline_time - variant_time) / baseline_time * 100
                        improvements[variant].append((matrix, improvement))
                    else:
                        print(f"Skipping improvement calculation for {variant}, matrix {matrix}, {time_type}: Variant time = {variant_time}, Baseline time = {baseline_time}")
    
    return improvements

def plot_improvements(improvements, matrix_files, ax, time_type):
    variants = list(improvements.keys())
    n_variants = len(variants)
    n_matrices = len(matrix_files)
    
    if n_variants == 0:
        ax.text(0.5, 0.5, f"No improvements to show for {time_type}",
                ha='center', va='center', fontsize=12)
        ax.set_title(f'{time_type.replace("_", " ").capitalize()} Time Improvement', fontsize=16)
        ax.axis('off')
        return

    width = 0.8 / n_variants
    x = np.arange(n_matrices)
    
    for j, variant in enumerate(variants):
        data = improvements[variant]
        x_pos = [matrix_files.index(d[0]) for d in data]
        y_pos = [d[1] for d in data]
        bars = ax.bar(np.array(x_pos) + j*width - (n_variants-1)*width/2, y_pos, width, label=variant, alpha=0.8)
        
        for bar in bars:
            height = bar.get_height()
            ax.annotate(f'{height:.1f}%',
                        xy=(bar.get_x() + bar.get_width() / 2, height),
                        xytext=(0, 3),
                        textcoords="offset points",
                        ha='center', va='bottom', rotation=90, fontsize=8)

    ax.set_title(f'{time_type.replace("_", " ").capitalize()} Time Improvement', fontsize=16)
    ax.set_xlabel('Matrices', fontsize=14)
    ax.set_ylabel('Improvement (%)', fontsize=14)
    ax.set_xticks(x)
    ax.set_xticklabels([os.path.basename(f) for f in matrix_files], rotation=45, ha='right', fontsize=8)
    ax.legend(fontsize=10, loc='upper left', bbox_to_anchor=(1, 1))
    ax.grid(axis='y', linestyle='--', alpha=0.7)
    ax.axhline(y=0, color='r', linestyle='-', linewidth=0.5)

def plot_all_improvements(results, matrix_files, selected_executables):
    time_types = ['convert', 'multiply_add', 'form_vector', 'total']
    
    fig, axs = plt.subplots(2, 2, figsize=(20, 20))
    
    for i, (ax, time_type) in enumerate(zip(axs.flat, time_types)):
        improvements = calculate_improvements(results, time_type, selected_executables)
        plot_improvements(improvements, matrix_files, ax, time_type)
    
    plt.tight_layout()
    plt.show()

# Load results from JSON file
results = load_results('spmv_results.json')

# List of all matrix files
matrix_files = list(next(iter(results.values())).keys())

# Select which executables to visualize
selected_executables = [
    "normal_double_scalar_gcc",
    #"normal_double_avx_gcc",
    #"normal_double_sse_gcc",
    "10x_double_scalar_gcc",
    #"10x_double_avx_gcc",
    #"10x_double_sse_gcc",
    
    #"normal_float_scalar_gcc",
    #"normal_float_avx_gcc",
    #"normal_float_sse_gcc",
    #"10x_float_scalar_gcc",
    #"10x_float_avx_gcc",
    #"10x_float_sse_gcc",
    
    #"normal_double_scalar_icc",
    #"normal_double_avx_icc",
    #"normal_double_sse_icc",
    #"10x_double_scalar_icc",
    #"10x_double_avx_icc",
    #"10x_double_sse_icc",
    
    #"normal_float_scalar_icc",
    #"normal_float_avx_icc",
    #"normal_float_sse_icc",
    #"10x_float_scalar_icc",
    #"10x_float_avx_icc",
    #"10x_float_sse_icc",
    
    
    
    
]

# Generate plots
plot_results(results, selected_executables)
plot_all_improvements(results, matrix_files, selected_executables)


# In[ ]:




